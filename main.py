"""Atlas Travel Telegram bot.

This module provides a multi-language Telegram bot that lets users search for
flight itineraries via an external flights API. The bot guides the user through
language selection, origin and destination input, date selection, and displays
the closest flight options returned by the API.

Environment variables:
    TELEGRAM_BOT_TOKEN: Token obtained from BotFather to run the Telegram bot.
    TEQUILA_API_KEY: Kiwi.com (Tequila) API key used to query flight offers.
"""

from __future__ import annotations

import logging
import os
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import requests
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

# Enable logging so we can trace the bot's behaviour when running on a server.
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
LOGGER = logging.getLogger(__name__)

# Conversation states
CHOOSING_LANGUAGE, ORIGIN, DESTINATION, DATE = range(4)


@dataclass
class Flight:
    """Represents a single flight itinerary returned from the API."""

    airline: str
    flight_number: str
    departure_airport: str
    arrival_airport: str
    departure_time: datetime
    arrival_time: datetime
    price: float
    currency: str

    def format_for_user(self, language: str) -> str:
        """Return a human-readable message for the user."""

        # Localised message fragments.
        templates = {
            "ru": "–ê–≤–∏–∞–∫–æ–º–ø–∞–Ω–∏—è {airline} {flight_number}\n–í—ã–ª–µ—Ç: {dep_airport} {dep_time}\n–ü—Ä–∏–ª–µ—Ç: {arr_airport} {arr_time}\n–¶–µ–Ω–∞: {price} {currency}",
            "uz": "Aviakompaniya {airline} {flight_number}\nJo'nash: {dep_airport} {dep_time}\nYetib kelish: {arr_airport} {arr_time}\nNarxi: {price} {currency}",
            "tg": "–®–∏—Ä–∫–∞—Ç–∏ “≥–∞–≤–æ–ø–∞–π–º–æ–∏–∏ {airline} {flight_number}\n–ü–∞—Ä–≤–æ–∑: {dep_airport} {dep_time}\n–§—É—Ä—É–¥: {arr_airport} {arr_time}\n–ù–∞—Ä—Ö: {price} {currency}",
            "kk": "”ò—É–µ –∫–æ–º–ø–∞–Ω–∏—è—Å—ã {airline} {flight_number}\n“∞—à—É: {dep_airport} {dep_time}\n“ö–æ–Ω—É: {arr_airport} {arr_time}\n–ë–∞“ì–∞—Å—ã: {price} {currency}",
            "ky": "–ê–≤–∏–∞–∫–æ–º–ø–∞–Ω–∏—è {airline} {flight_number}\n–£—á—É—É: {dep_airport} {dep_time}\n–ö–æ–Ω—É—É: {arr_airport} {arr_time}\n–ë–∞–∞—Å—ã: {price} {currency}",
            "en": "Airline {airline} {flight_number}\nDeparture: {dep_airport} {dep_time}\nArrival: {arr_airport} {arr_time}\nPrice: {price} {currency}",
        }
        template = templates.get(language, templates["en"])
        return template.format(
            airline=self.airline,
            flight_number=self.flight_number,
            dep_airport=self.departure_airport,
            arr_airport=self.arrival_airport,
            dep_time=self.departure_time.strftime("%d.%m.%Y %H:%M"),
            arr_time=self.arrival_time.strftime("%d.%m.%Y %H:%M"),
            price=f"{self.price:.2f}",
            currency=self.currency,
        )


class FlightAPIError(Exception):
    """Raised when the flight API returns an error or invalid response."""


class FlightAPIClient:
    """Client wrapper for the Kiwi.com (Tequila) flights API."""

    BASE_URL = "https://api.tequila.kiwi.com/v2/search"

    def __init__(self, api_key: str) -> None:
        if not api_key:
            raise FlightAPIError("Missing Kiwi.com API key")
        self.api_key = api_key

    def search_flights(
        self, origin: str, destination: str, date: datetime
    ) -> List[Flight]:
        """Search for flights around the specified date.

        The API is queried with a +/- 3 day window to provide nearby flights.
        """

        date_from = (date - timedelta(days=3)).strftime("%d/%m/%Y")
        date_to = (date + timedelta(days=3)).strftime("%d/%m/%Y")

        params = {
            "fly_from": origin,
            "fly_to": destination,
            "date_from": date_from,
            "date_to": date_to,
            "curr": "USD",
            "limit": 5,
            "sort": "price",
        }

        headers = {"apikey": self.api_key}
        response = requests.get(self.BASE_URL, params=params, headers=headers, timeout=20)

        if response.status_code != 200:
            LOGGER.error("Flight API error: %s", response.text)
            raise FlightAPIError(f"Flight API error: {response.status_code}")

        data = response.json()
        if "data" not in data:
            raise FlightAPIError("Unexpected API response format")

        flights: List[Flight] = []
        for item in data["data"]:
            try:
                flights.append(
                    Flight(
                        airline=item["airlines"][0] if item.get("airlines") else "?",
                        flight_number=item.get("route", [{}])[0].get("flight_no", "?"),
                        departure_airport=item.get("flyFrom", ""),
                        arrival_airport=item.get("flyTo", ""),
                        departure_time=datetime.fromtimestamp(item["dTimeUTC"]),
                        arrival_time=datetime.fromtimestamp(item["aTimeUTC"]),
                        price=float(item.get("price", 0.0)),
                        currency=data.get("currency", "USD"),
                    )
                )
            except (KeyError, TypeError, ValueError) as error:
                LOGGER.warning("Skipping flight due to malformed data: %s", error)
                continue
        return flights


LANGUAGE_PACK: Dict[str, Dict[str, str]] = {
    "ru": {
        "label": "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
        "choose_language": "–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫",
        "ask_origin": "–í–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥ –∏–ª–∏ –∞—ç—Ä–æ–ø–æ—Ä—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, MOW –∏–ª–∏ –ú–æ—Å–∫–≤–∞)",
        "ask_destination": "–í–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥ –∏–ª–∏ –∞—ç—Ä–æ–ø–æ—Ä—Ç –ø—Ä–∏–±—ã—Ç–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, TSE –∏–ª–∏ –ê—Å—Ç–∞–Ω–∞)",
        "ask_date": "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤—ã–ª–µ—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì",
        "invalid_date": "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ (–î–î.–ú–ú.–ì–ì–ì–ì)",
        "searching": "–ò—â—É –±–ª–∏–∂–∞–π—à–∏–µ —Ä–µ–π—Å—ã...",
        "no_flights": "–†–µ–π—Å—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥—É—é –¥–∞—Ç—É –∏–ª–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ.",
        "api_key_missing": "API –∫–ª—é—á –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
        "error": "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ —Ä–µ–π—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
        "cancelled": "–ü–æ–∏—Å–∫ –æ—Ç–º–µ–Ω—ë–Ω. –ù–∞–ø–∏—à–∏—Ç–µ /start —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.",
    },
    "uz": {
        "label": "üá∫üáø O'zbekcha",
        "choose_language": "Tilni tanlang",
        "ask_origin": "Jo'nash shahri yoki aeroportini kiriting (masalan, TAS yoki Toshkent)",
        "ask_destination": "Borish shahri yoki aeroportini kiriting (masalan, DXB yoki Dubay)",
        "ask_date": "Parvoz sanasini DD.MM.YYYY shaklida kiriting",
        "invalid_date": "Sana formati noto'g'ri. Iltimos, DD.MM.YYYY ko'rinishida kiriting",
        "searching": "Yaqin parvozlar qidirilmoqda...",
        "no_flights": "Parvozlar topilmadi. Boshqa sanani yoki yo'nalishni sinab ko'ring.",
        "api_key_missing": "API kaliti sozlanmagan. Administrator bilan bog'laning.",
        "error": "Parvozlarni qidirishda xatolik yuz berdi. Keyinroq urinib ko'ring.",
        "cancelled": "Qidiruv bekor qilindi. Qayta boshlash uchun /start yozing.",
    },
    "tg": {
        "label": "üáπüáØ –¢–æ“∑–∏–∫”£",
        "choose_language": "–ó–∞–±–æ–Ω—Ä–æ –∏–Ω—Ç–∏—Ö–æ–± –∫—É–Ω–µ–¥",
        "ask_origin": "–®–∞“≥—Ä —ë —Ñ—É—Ä—É–¥–≥–æ“≥–∏ –ø–∞—Ä–≤–æ–∑—Ä–æ –≤–æ—Ä–∏–¥ –∫—É–Ω–µ–¥ (–º–∞—Å–∞–ª–∞–Ω, DYU —ë –î—É—à–∞–Ω–±–µ)",
        "ask_destination": "–®–∞“≥—Ä —ë —Ñ—É—Ä—É–¥–≥–æ“≥–∏ –Ω–∏—à–∞—Å—Ç—Ä–æ –≤–æ—Ä–∏–¥ –∫—É–Ω–µ–¥ (–º–∞—Å–∞–ª–∞–Ω, IST —ë –ò—Å—Ç–∞–Ω–±—É–ª)",
        "ask_date": "–°–∞–Ω–∞–∏ –ø–∞—Ä–≤–æ–∑—Ä–æ –±–æ —Ñ–æ—Ä–º–∞—Ç–∏ –†–†.–ú–ú.–°–°–°–° –≤–æ—Ä–∏–¥ –∫—É–Ω–µ–¥",
        "invalid_date": "–°–∞–Ω–∞ –Ω–æ–¥—É—Ä—É—Å—Ç –∞—Å—Ç. –ú–∞—Ä“≥–∞–º–∞—Ç –∫–∞—Ä–¥–∞, –†–†.–ú–ú.–°–°–°–°-—Ä–æ –≤–æ—Ä–∏–¥ –∫—É–Ω–µ–¥",
        "searching": "–ü–∞—Ä–≤–æ–∑“≥–æ–∏ –Ω–∞–∑–¥–∏–∫ “∑—É—Å—Ç—É“∑”Ø –º–µ—à–∞–≤–∞–Ω–¥...",
        "no_flights": "–ü–∞—Ä–≤–æ–∑ —ë—Ñ—Ç –Ω–∞—à—É–¥. –°–∞–Ω–∞ —ë —Å–∞–º—Ç–∏ –¥–∏–≥–∞—Ä—Ä–æ —Å–∞–Ω“∑–µ–¥.",
        "api_key_missing": "–ö–∞–ª–∏–¥–∏ API —Ç–∞–Ω–∑–∏–º –Ω–∞—à—É–¥–∞–∞—Å—Ç. –õ—É—Ç—Ñ–∞–Ω –±–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º—É—Ä–æ“∑–∏–∞—Ç –∫—É–Ω–µ–¥.",
        "error": "“≤–∞–Ω–≥–æ–º–∏ “∑—É—Å—Ç—É“∑”Ø–∏ –ø–∞—Ä–≤–æ–∑“≥–æ —Ö–∞—Ç–æ —à—É–¥. –ë–∞—ä–¥—Ç–∞—Ä –∫”Ø—à–∏—à –∫—É–Ω–µ–¥.",
        "cancelled": "“∂—É—Å—Ç—É“∑”Ø –±–µ–∫–æ—Ä –∫–∞—Ä–¥–∞ —à—É–¥. –ë–∞—Ä–æ–∏ –∞–∑ –Ω–∞–≤ –æ“ì–æ–∑ –∫–∞—Ä–¥–∞–Ω /start –Ω–∞–≤–∏—Å–µ–¥.",
    },
    "kk": {
        "label": "üá∞üáø “ö–∞–∑–∞“õ—à–∞",
        "choose_language": "–¢—ñ–ª–¥—ñ —Ç–∞“£–¥–∞“£—ã–∑",
        "ask_origin": "“∞—à—É “õ–∞–ª–∞—Å—ã–Ω –Ω–µ–º–µ—Å–µ ”ô—É–µ–∂–∞–π—ã–Ω –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑ (–º—ã—Å–∞–ª—ã, ALA –Ω–µ–º–µ—Å–µ –ê–ª–º–∞—Ç—ã)",
        "ask_destination": "“ö–æ–Ω—É “õ–∞–ª–∞—Å—ã–Ω –Ω–µ–º–µ—Å–µ ”ô—É–µ–∂–∞–π—ã–Ω –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑ (–º—ã—Å–∞–ª—ã, NQZ –Ω–µ–º–µ—Å–µ –ê—Å—Ç–∞–Ω–∞)",
        "ask_date": "“∞—à—É –∫“Ø–Ω—ñ–Ω –ö–ö.–ê–ê.–ñ–ñ–ñ–ñ —Ñ–æ—Ä–º–∞—Ç—ã–Ω–¥–∞ –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑",
        "invalid_date": "–ö“Ø–Ω —Ñ–æ—Ä–º–∞—Ç—ã “õ–∞—Ç–µ. “ö–∞–π—Ç–∞–¥–∞–Ω –ö–ö.–ê–ê.–ñ–ñ–ñ–ñ –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑",
        "searching": "–ñ–∞“õ—ã–Ω —Ä–µ–π—Å—Ç–µ—Ä —ñ–∑–¥–µ–ª—É–¥–µ...",
        "no_flights": "–†–µ–π—Å—Ç–µ—Ä —Ç–∞–±—ã–ª–º–∞–¥—ã. –ë–∞—Å“õ–∞ –∫“Ø–Ω–¥—ñ –Ω–µ–º–µ—Å–µ –±–∞“ì—ã—Ç—Ç—ã –∫”©—Ä—ñ“£—ñ–∑.",
        "api_key_missing": "API –∫—ñ–ª—Ç—ñ –±–∞–ø—Ç–∞–ª–º–∞“ì–∞–Ω. ”ò–∫—ñ–º—à—ñ–≥–µ —Ö–∞–±–∞—Ä–ª–∞—Å—ã“£—ã–∑.",
        "error": "–†–µ–π—Å—Ç–µ—Ä–¥—ñ —ñ–∑–¥–µ—É –∫–µ–∑—ñ–Ω–¥–µ “õ–∞—Ç–µ –∫–µ—Ç—Ç—ñ. –ö–µ–π—ñ–Ω—ñ—Ä–µ–∫ “õ–∞–π—Ç–∞–ª–∞–ø –∫”©—Ä—ñ“£—ñ–∑.",
        "cancelled": "–Ü–∑–¥–µ—É —Ç–æ“õ—Ç–∞—Ç—ã–ª–¥—ã. “ö–∞–π—Ç–∞ –±–∞—Å—Ç–∞—É “Ø—à—ñ–Ω /start –∂–∞–∑—ã“£—ã–∑.",
    },
    "ky": {
        "label": "üá∞üá¨ –ö—ã—Ä–≥—ã–∑—á–∞",
        "choose_language": "–¢–∏–ª–¥–∏ —Ç–∞–Ω–¥–∞“£—ã–∑",
        "ask_origin": "–£—á—É–ø —á—ã–≥—É—É—á—É —à–∞–∞—Ä–¥—ã –∂–µ –∞—ç—Ä–æ–ø–æ—Ä—Ç—Ç—É –∂–∞–∑—ã“£—ã–∑ (–º–∏—Å–∞–ª—ã, FRU –∂–µ –ë–∏—à–∫–µ–∫)",
        "ask_destination": "–£—á—É–ø –±–∞—Ä–∞ —Ç—É—Ä–≥–∞–Ω —à–∞–∞—Ä–¥—ã –∂–µ –∞—ç—Ä–æ–ø–æ—Ä—Ç—Ç—É –∂–∞–∑—ã“£—ã–∑ (–º–∏—Å–∞–ª—ã, OSS –∂–µ –û—à)",
        "ask_date": "–£—á—É—É –∫“Ø–Ω“Ø–Ω –ö–ö.–ê–ê.–ñ–ñ–ñ–ñ —Ñ–æ—Ä–º–∞—Ç—ã–Ω–¥–∞ –∂–∞–∑—ã“£—ã–∑",
        "invalid_date": "–ö“Ø–Ω —Ñ–æ—Ä–º–∞—Ç—ã —Ç—É—É—Ä–∞ —ç–º–µ—Å. –ö–∞–π—Ä–∞–¥–∞–Ω –ö–ö.–ê–ê.–ñ–ñ–ñ–ñ –∂–∞–∑—ã“£—ã–∑",
        "searching": "–ñ–∞–∫—ã–Ω–∫—ã —Ä–µ–π—Å—Ç–µ—Ä –∏–∑–¥”©”©–¥”©...",
        "no_flights": "–†–µ–π—Å—Ç–µ—Ä —Ç–∞–±—ã–ª–≥–∞–Ω –∂–æ–∫. –ë–∞—à–∫–∞ –∫“Ø–Ω –∂–µ –±–∞–≥—ã—Ç—Ç—ã —Ç–∞–Ω–¥–∞“£—ã–∑.",
        "api_key_missing": "API –∞—á–∫—ã—á—ã –æ—Ä–Ω–æ—Ç—É–ª–≥–∞–Ω —ç–º–µ—Å. –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–≥–æ –∫–∞–π—Ä—ã–ª—ã“£—ã–∑.",
        "error": "–†–µ–π—Å—Ç–µ—Ä–¥–∏ –∏–∑–¥”©”©–¥”© –∫–∞—Ç–∞ –∫–µ—Ç—Ç–∏. –ö–∏–π–∏–Ω—á–µ—Ä—ç—ç–∫ –∞—Ä–∞–∫–µ—Ç –∫—ã–ª—ã“£—ã–∑.",
        "cancelled": "–ò–∑–¥”©”© —Ç–æ–∫—Ç–æ—Ç—É–ª–¥—É. –ö–∞–π—Ä–∞ –±–∞—à—Ç–æ–æ “Ø—á“Ø–Ω /start –∂–∞–∑—ã“£—ã–∑.",
    },
    "en": {
        "label": "üá¨üáß English",
        "choose_language": "Choose your language",
        "ask_origin": "Enter departure city or airport (e.g. NYC or New York)",
        "ask_destination": "Enter arrival city or airport (e.g. LON or London)",
        "ask_date": "Enter departure date in DD.MM.YYYY format",
        "invalid_date": "Invalid date format. Please use DD.MM.YYYY",
        "searching": "Searching for the nearest flights...",
        "no_flights": "No flights found. Try a different date or route.",
        "api_key_missing": "API key is not configured. Please contact the administrator.",
        "error": "An error occurred while searching for flights. Please try again later.",
        "cancelled": "Search cancelled. Type /start to begin again.",
    },
}


def get_text(language: str, key: str) -> str:
    """Return the text for a given language and key with English fallback."""

    language_pack = LANGUAGE_PACK.get(language)
    if language_pack and key in language_pack:
        return language_pack[key]
    return LANGUAGE_PACK["en"].get(key, "")


def build_language_keyboard() -> InlineKeyboardMarkup:
    """Create an inline keyboard for language selection."""

    buttons = [
        [InlineKeyboardButton(pack["label"], callback_data=code)]
        for code, pack in LANGUAGE_PACK.items()
    ]
    return InlineKeyboardMarkup(buttons)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle the /start command by asking the user to select a language."""

    keyboard = build_language_keyboard()
    if update.message:
        await update.message.reply_text(
            get_text("en", "choose_language"), reply_markup=keyboard
        )
    else:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text(
            get_text("en", "choose_language"), reply_markup=keyboard
        )
    return CHOOSING_LANGUAGE


async def language_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Callback after the user picks a language."""

    query = update.callback_query
    await query.answer()

    language = query.data
    context.user_data["language"] = language

    await query.edit_message_text(get_text(language, "ask_origin"))
    return ORIGIN


async def handle_origin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Store the origin provided by the user and ask for the destination."""

    language = context.user_data.get("language", "en")
    context.user_data["origin"] = update.message.text.strip()
    await update.message.reply_text(get_text(language, "ask_destination"))
    return DESTINATION


async def handle_destination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Store the destination and ask for the travel date."""

    language = context.user_data.get("language", "en")
    context.user_data["destination"] = update.message.text.strip()
    await update.message.reply_text(get_text(language, "ask_date"))
    return DATE


def parse_date(date_str: str) -> Optional[datetime]:
    """Parse a date in DD.MM.YYYY format."""

    try:
        return datetime.strptime(date_str, "%d.%m.%Y")
    except ValueError:
        return None


async def handle_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Validate the date, query the API and display flight options."""

    language = context.user_data.get("language", "en")
    date_text = update.message.text.strip()
    travel_date = parse_date(date_text)

    if travel_date is None:
        await update.message.reply_text(get_text(language, "invalid_date"))
        return DATE

    origin = context.user_data.get("origin")
    destination = context.user_data.get("destination")

    api_key = os.getenv("TEQUILA_API_KEY")
    if not api_key:
        await update.message.reply_text(get_text(language, "api_key_missing"))
        return ConversationHandler.END

    await update.message.reply_text(get_text(language, "searching"))

    try:
        client = FlightAPIClient(api_key)
        flights = client.search_flights(origin, destination, travel_date)
    except FlightAPIError:
        LOGGER.exception("Failed to retrieve flights")
        await update.message.reply_text(get_text(language, "error"))
        return ConversationHandler.END

    if not flights:
        await update.message.reply_text(get_text(language, "no_flights"))
        return ConversationHandler.END

    for flight in flights:
        await update.message.reply_text(flight.format_for_user(language))

    await update.message.reply_text(get_text(language, "cancelled"))
    return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Allow the user to cancel the conversation."""

    language = context.user_data.get("language", "en")
    if update.message:
        await update.message.reply_text(get_text(language, "cancelled"))
    return ConversationHandler.END


def build_application() -> Application:
    """Create the Telegram application with handlers."""

    token = os.getenv("TELEGRAM_BOT_TOKEN")
    if not token:
        raise RuntimeError("TELEGRAM_BOT_TOKEN environment variable is required")

    application = Application.builder().token(token).build()

    conversation = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            CHOOSING_LANGUAGE: [CallbackQueryHandler(language_selected)],
            ORIGIN: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_origin)],
            DESTINATION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_destination)],
            DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_date)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        name="flight_search_conversation",
        persistent=False,
    )

    application.add_handler(conversation)
    return application


def main() -> None:
    """Entrypoint for running the Telegram bot."""

    application = build_application()
    LOGGER.info("Starting Atlas Travel bot")
    application.run_polling()


if __name__ == "__main__":
    main()
