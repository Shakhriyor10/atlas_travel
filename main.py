import asyncio
import json
import logging
import sqlite3
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from urllib import error, parse, request

from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import (CallbackQuery, InlineKeyboardButton,
                           InlineKeyboardMarkup, Message)

API_TOKEN = "a89e7cbe4ff3ee19f171cab072b53881"
TELEGRAM_TOKEN = "8396669139:AAFvr8gWi7uXDMwPLBePF9NmYf16wsHmtPU"
API_URL = "https://api.travelpayouts.com/aviasales/v3/prices_for_dates"
AUTOCOMPLETE_URL = "https://autocomplete.travelpayouts.com/places2"
AIRLINES_URL = "https://api.travelpayouts.com/data/airlines.json"

DATABASE_PATH = Path("bot_data.db")

LANGUAGE_OPTIONS = [
    ("ru", "üá∑üá∫ –†—É—Å—Å–∫–∏–π"),
    ("uz", "üá∫üáø O'zbek"),
    ("tg", "üáπüáØ –¢–æ“∑–∏–∫”£"),
    ("kk", "üá∞üáø “ö–∞–∑–∞“õ—à–∞"),
    ("ky", "üá∞üá¨ –ö—ã—Ä–≥—ã–∑—á–∞"),
    ("en", "üá¨üáß English"),
]

LANGUAGE_PROMPT = (
    "üá∑üá∫ –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è\n"
    "üá∫üáø Tilni tanlang\n"
    "üáπüáØ –ó–∞–±–æ–Ω—Ä–æ –∏–Ω—Ç–∏—Ö–æ–± –∫—É–Ω–µ–¥\n"
    "üá∞üáø –¢—ñ–ª–¥—ñ —Ç–∞“£–¥–∞“£—ã–∑\n"
    "üá∞üá¨ –¢–∏–ª–¥–∏ —Ç–∞–Ω–¥–∞“£—ã–∑\n"
    "üá¨üáß Please choose your language"
)

LANGUAGE_TO_LOCALE = {
    "ru": "ru",
    "uz": "ru",
    "tg": "ru",
    "kk": "ru",
    "ky": "ru",
    "en": "en",
}

SHOW_NEAREST_CALLBACK = "date:any"
ACTION_SEARCH = "action:search"
ACTION_CHANGE_LANGUAGE = "action:change_language"
MAX_RESULTS = 200
TELEGRAM_MESSAGE_LIMIT = 3500

_AIRLINES_CACHE: Optional[Dict[str, Dict[str, Any]]] = None
_AIRLINES_LOCK = asyncio.Lock()

AIRLINE_LANGUAGE_PREFERENCES: Dict[str, Tuple[str, ...]] = {
    "en": ("en", "ru"),
    "ru": ("ru", "en"),
    "uz": ("ru", "en"),
    "tg": ("ru", "en"),
    "kk": ("ru", "en"),
    "ky": ("ru", "en"),
}

MESSAGES: Dict[str, Dict[str, str]] = {
    "ru": {
        "choose_language": "–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è:",
        "choose_action": "–ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å?",
        "search_flights": "–ü–æ–∏—Å–∫ –∞–≤–∏–∞–±–∏–ª–µ—Ç–æ–≤",
        "change_language": "–ò–∑–º–µ–Ω–∏—Ç—å —è–∑—ã–∫",
        "ask_origin": "‚úàÔ∏è –í–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–ª–∏ –µ–≥–æ IATA-–∫–æ–¥ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ú–æ—Å–∫–≤–∞ –∏–ª–∏ MOW).",
        "ask_destination": "üìç –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ –≥–æ—Ä–æ–¥ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∏–ª–∏ IATA-–∫–æ–¥ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –î—É–±–∞–π –∏–ª–∏ DXB).",
        "ask_date": "üìÖ –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤—ã–ª–µ—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î –∏–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –±–ª–∏–∂–∞–π—à–∏–µ —Ä–µ–π—Å—ã.",
        "invalid_date": "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î.",
        "invalid_city": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ—Ä–æ–¥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–∫–∞–∑–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–ª–∏ IATA-–∫–æ–¥.",
        "searching": "üîé –ò—â—É –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Ä–µ–π—Å—ã...",
        "error_fetch": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ —Ä–µ–π—Å–∞—Ö. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
        "no_flights": "–ë–ª–∏–∂–∞–π—à–∏—Ö —Ä–µ–π—Å–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.",
        "results_header": "–í–æ—Ç —á—Ç–æ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏:",
        "new_search": "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –≥–æ—Ä–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è, —á—Ç–æ–±—ã –∏—Å–∫–∞—Ç—å —Å–Ω–æ–≤–∞, –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è —Å–º–µ–Ω—ã —è–∑—ã–∫–∞.",
        "missing_data": "–î–∞–Ω–Ω—ã–µ –ø–æ–∏—Å–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∏. –ù–∞–∂–º–∏—Ç–µ /start, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.",
        "nearest_button": "–ü–æ–∫–∞–∑–∞—Ç—å –±–ª–∏–∂–∞–π—à–∏–µ —Ä–µ–π—Å—ã",
        "departure": "–í—ã–ª–µ—Ç",
        "arrival": "–ü—Ä–∏–ª–µ—Ç",
        "airline": "–ê–≤–∏–∞–∫–æ–º–ø–∞–Ω–∏—è",
        "flight_number": "–†–µ–π—Å",
        "price": "–¶–µ–Ω–∞",
        "aircraft": "–°–∞–º–æ–ª–µ—Ç",
    },
    "uz": {
        "choose_language": "Tilni tanlang:",
        "choose_action": "Qaysi amalni bajaramiz?",
        "search_flights": "Aviabilet qidirish",
        "change_language": "Tilni o'zgartirish",
        "ask_origin": "‚úàÔ∏è Uchish shahrining nomini yoki IATA kodini kiriting (masalan, Toshkent yoki TAS).",
        "ask_destination": "üìç Endi boradigan manzilning nomini yoki IATA kodini yozing (masalan, Dubay yoki DXB).",
        "ask_date": "üìÖ Parvoz sanasini YYYY-MM-DD formatida kiriting yoki quyidagi tugmadan eng yaqin reyslarni tanlang.",
        "invalid_date": "Sana formati noto'g'ri. Iltimos, YYYY-MM-DD formatidan foydalaning.",
        "invalid_city": "Shaharni aniqlab bo'lmadi. Nomini yoki IATA kodini qaytadan kiriting.",
        "searching": "üîé Parvozlar qidirilmoqda...",
        "error_fetch": "Parvoz ma'lumotlarini olish muvaffaq–∏–πatsiz tugadi. Birozdan so'ng qay—Ç–∞ urinib ko'ring.",
        "no_flights": "Yaqqin reyslar topilmadi.",
        "results_header": "Topilgan variantlar:",
        "new_search": "Qayta qidirish uchun yangi uchish shahrini kiriting yoki tilni almashtirish uchun /start yuboring.",
        "missing_data": "Qidiruv ma'lumotlari eskirdi. /start yuborib yangidan boshlang.",
        "nearest_button": "Eng yaqin reyslar",
        "departure": "Uchish",
        "arrival": "Qo'nish",
        "airline": "Aviakompaniya",
        "flight_number": "Reys",
        "price": "Narxi",
        "aircraft": "Samolyot",
    },
    "tg": {
        "choose_language": "–ó–∞–±–æ–Ω–∏ —Ö–∏–∑–º–∞—Ç—Ä–∞—Å–æ–Ω–∏—Ä–æ –∏–Ω—Ç–∏—Ö–æ–± –∫—É–Ω–µ–¥:",
        "choose_action": "–ê–º–∞–ª–∏ –ª–æ–∑–∏–º–∏—Ä–æ –∏–Ω—Ç–∏—Ö–æ–± –∫—É–Ω–µ–¥:",
        "search_flights": "“∂—É—Å—Ç—É“∑”Ø–∏ –ø–∞—Ä–≤–æ–∑“≥–æ",
        "change_language": "–¢–∞“ì–π–∏—Ä–∏ –∑–∞–±–æ–Ω",
        "ask_origin": "‚úàÔ∏è –ù–æ–º–∏ —à–∞“≥—Ä —ë —Ä–∞–º–∑–∏ IATA-–∏ –ø–∞—Ä–≤–æ–∑—Ä–æ –≤–æ—Ä–∏–¥ –∫—É–Ω–µ–¥ (–º–∞—Å–∞–ª–∞–Ω, –î—É—à–∞–Ω–±–µ —ë DYU).",
        "ask_destination": "üìç –ê–∫–Ω—É–Ω –Ω–æ–º–∏ —Å–∞–º—Ç —ë —Ä–∞–º–∑–∏ IATA-—Ä–æ –Ω–∞–≤–∏—Å–µ–¥ (–º–∞—Å–∞–ª–∞–Ω, –î—É–±–∞–π —ë DXB).",
        "ask_date": "üìÖ –°–∞–Ω–∞–∏ –ø–∞—Ä–≤–æ–∑—Ä–æ –±–∞ —à–∞–∫–ª–∏ YYYY-MM-DD –≤–æ—Ä–∏–¥ –∫—É–Ω–µ–¥ —ë –∞–∑ —Ç—É–≥–º–∞–∏ –ø–æ—ë–Ω –±–∞—Ä–æ–∏ –ø–∞—Ä–≤–æ–∑“≥–æ–∏ –Ω–∞–∑–¥–∏–∫ –∏—Å—Ç–∏—Ñ–æ–¥–∞ –±–∞—Ä–µ–¥.",
        "invalid_date": "–°–∞–Ω–∞ –Ω–æ–¥—É—Ä—É—Å—Ç –∞—Å—Ç. –§–æ—Ä–º–∞—Ç–∏ YYYY-MM-DD-—Ä–æ –∏—Å—Ç–∏—Ñ–æ–¥–∞ –±–∞—Ä–µ–¥.",
        "invalid_city": "–®–∞“≥—Ä —à–∏–Ω–æ—Ö—Ç–∞ –Ω–∞—à—É–¥. –õ—É—Ç—Ñ–∞–Ω –Ω–æ–º —ë —Ä–∞–º–∑–∏ IATA-—Ä–æ –≤–æ—Ä–∏–¥ –∫—É–Ω–µ–¥.",
        "searching": "üîé –ü–∞—Ä–≤–æ–∑“≥–æ “∑—É—Å—Ç—É“∑”Ø –º–µ—à–∞–≤–∞–Ω–¥...",
        "error_fetch": "–ú–∞—ä–ª—É–º–æ—Ç –¥–∞—Ä –±–æ—Ä–∞–∏ –ø–∞—Ä–≤–æ–∑“≥–æ –¥–∞—Å—Ç–Ω–æ—Ä–∞—Å –∞—Å—Ç. –õ—É—Ç—Ñ–∞–Ω –¥–µ—Ä—Ç–∞—Ä –∫”Ø—à–∏—à –∫—É–Ω–µ–¥.",
        "no_flights": "–ü–∞—Ä–≤–æ–∑“≥–æ–∏ –Ω–∞–∑–¥–∏–∫ —ë—Ñ—Ç –Ω–∞—à—É–¥–∞–Ω–¥.",
        "results_header": "–ò–Ω –Ω–∞—Ç–∏“∑–∞“≥–æ –¥–∞—Å—Ç—Ä–∞—Å–∞–Ω–¥:",
        "new_search": "–ë–∞—Ä–æ–∏ “∑—É—Å—Ç—É“∑”Ø–∏ –¥—É–±–æ—Ä–∞ —à–∞“≥—Ä—Ä–æ –∞–∑ –Ω–∞–≤ –≤–æ—Ä–∏–¥ –∫—É–Ω–µ–¥ —ë –±–∞—Ä–æ–∏ –∏–≤–∞–∑ –∫–∞—Ä–¥–∞–Ω–∏ –∑–∞–±–æ–Ω /start-—Ä–æ –∏—Å—Ç–∏—Ñ–æ–¥–∞ –±–∞—Ä–µ–¥.",
        "missing_data": "–ú–∞—ä–ª—É–º–æ—Ç–∏ “∑—É—Å—Ç—É“∑”Ø –∫—É“≥–Ω–∞ —à—É–¥. –ë–∞—Ä–æ–∏ –æ“ì–æ–∑ –∞–∑ –Ω–∞–≤ /start-—Ä–æ —Ñ–∏—Ä–∏—Å—Ç–µ–¥.",
        "nearest_button": "–ü–∞—Ä–≤–æ–∑“≥–æ–∏ –Ω–∞–∑–¥–∏–∫",
        "departure": "–ü–∞—Ä–≤–æ–∑",
        "arrival": "–§—É—Ä—É–¥",
        "airline": "–®–∏—Ä–∫–∞—Ç–∏ “≥–∞–≤–æ–ø–∞–π–º–æ”£",
        "flight_number": "–®—É–º–æ—Ä–∞–∏ –ø–∞—Ä–≤–æ–∑",
        "price": "–ù–∞—Ä—Ö",
        "aircraft": "“≤–∞–≤–æ–ø–∞–π–º–æ",
    },
    "kk": {
        "choose_language": "“ö–∞–π —Ç—ñ–ª–¥–µ –∂–∞–ª“ì–∞—Å–∞–º—ã–∑?",
        "choose_action": "”ò—Ä—ñ “õ–∞—Ä–∞–π –Ω–µ —ñ—Å—Ç–µ–π–º—ñ–∑?",
        "search_flights": "”ò—É–µ –±–∏–ª–µ—Ç—Ç–µ—Ä—ñ–Ω —ñ–∑–¥–µ—É",
        "change_language": "–¢—ñ–ª–¥—ñ ”©–∑–≥–µ—Ä—Ç—É",
        "ask_origin": "‚úàÔ∏è “∞—à–∞—Ç—ã–Ω “õ–∞–ª–∞–Ω—ã“£ –∞—Ç–∞—É—ã–Ω –Ω–µ–º–µ—Å–µ IATA –∫–æ–¥—ã–Ω –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑ (–º—ã—Å–∞–ª—ã, –ê–ª–º–∞—Ç—ã –Ω–µ–º–µ—Å–µ ALA).",
        "ask_destination": "üìç –ï–Ω–¥—ñ –±–∞—Ä–∞—Ç—ã–Ω –±–∞“ì—ã—Ç—Ç—ã“£ –∞—Ç–∞—É—ã–Ω –Ω–µ–º–µ—Å–µ IATA –∫–æ–¥—ã–Ω –∂–∞–∑—ã“£—ã–∑ (–º—ã—Å–∞–ª—ã, –î—É–±–∞–π –Ω–µ–º–µ—Å–µ DXB).",
        "ask_date": "üìÖ “∞—à—É –∫“Ø–Ω—ñ–Ω YYYY-MM-DD —Ñ–æ—Ä–º–∞—Ç—ã–Ω–¥–∞ –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑ –Ω–µ–º–µ—Å–µ —Ç”©–º–µ–Ω–¥–µ–≥—ñ —Ç“Ø–π–º–µ–Ω—ñ –ø–∞–π–¥–∞–ª–∞–Ω—ã–ø –∂–∞“õ—ã–Ω —Ä–µ–π—Å—Ç–µ—Ä–¥—ñ –∫”©—Ä—ñ“£—ñ–∑.",
        "invalid_date": "–ö“Ø–Ω —Ñ–æ—Ä–º–∞—Ç—ã –¥“±—Ä—ã—Å –µ–º–µ—Å. YYYY-MM-DD —Ñ–æ—Ä–º–∞—Ç—Ç—ã –ø–∞–π–¥–∞–ª–∞–Ω—ã“£—ã–∑.",
        "invalid_city": "“ö–∞–ª–∞–Ω—ã –∞–Ω—ã“õ—Ç–∞—É –º“Ø–º–∫—ñ–Ω –±–æ–ª–º–∞–¥—ã. –ê—Ç–∞—É—ã–Ω –Ω–µ–º–µ—Å–µ IATA –∫–æ–¥—ã–Ω –∫”©—Ä—Å–µ—Ç—ñ“£—ñ–∑.",
        "searching": "üîé –†–µ–π—Å—Ç–µ—Ä —ñ–∑–¥–µ–ª—É–¥–µ...",
        "error_fetch": "–†–µ–π—Å—Ç–µ—Ä —Ç—É—Ä–∞–ª—ã –∞“õ–ø–∞—Ä–∞—Ç –∞–ª—É –º“Ø–º–∫—ñ–Ω –±–æ–ª–º–∞–¥—ã. –ö–µ–π—ñ–Ω—ñ—Ä–µ–∫ “õ–∞–π—Ç–∞ –∫”©—Ä—ñ“£—ñ–∑.",
        "no_flights": "–ñ–∞“õ—ã–Ω —Ä–µ–π—Å—Ç–µ—Ä —Ç–∞–±—ã–ª–º–∞–¥—ã.",
        "results_header": "–¢–∞–±—ã–ª“ì–∞–Ω “±—Å—ã–Ω—ã—Å—Ç–∞—Ä:",
        "new_search": "–ñ–∞“£–∞ —ñ–∑–¥–µ—É “Ø—à—ñ–Ω “±—à—É “õ–∞–ª–∞—Å—ã–Ω “õ–∞–π—Ç–∞ –µ–Ω–≥—ñ–∑—ñ“£—ñ–∑ –Ω–µ–º–µ—Å–µ —Ç—ñ–ª–¥—ñ –∞—É—ã—Å—Ç—ã—Ä—É “Ø—à—ñ–Ω /start –∫–æ–º–∞–Ω–¥–∞—Å—ã–Ω –ø–∞–π–¥–∞–ª–∞–Ω—ã“£—ã–∑.",
        "missing_data": "–Ü–∑–¥–µ—É –¥–µ—Ä–µ–∫—Ç–µ—Ä—ñ –µ—Å–∫—ñ—Ä–¥—ñ. “ö–∞–π—Ç–∞ –±–∞—Å—Ç–∞—É “Ø—à—ñ–Ω /start –∂—ñ–±–µ—Ä—ñ“£—ñ–∑.",
        "nearest_button": "–ñ–∞“õ—ã–Ω —Ä–µ–π—Å—Ç–µ—Ä",
        "departure": "“∞—à—É",
        "arrival": "“ö–æ–Ω—É",
        "airline": "”ò—É–µ –∫–æ–º–ø–∞–Ω–∏—è—Å—ã",
        "flight_number": "–†–µ–π—Å",
        "price": "–ë–∞“ì–∞—Å—ã",
        "aircraft": "“∞—à–∞“õ",
    },
    "ky": {
        "choose_language": "–¢–∏–ª–¥–∏ —Ç–∞–Ω–¥–∞“£—ã–∑:",
        "choose_action": "–ö–∞–π—Å—ã –∏—à-–∞—Ä–∞–∫–µ—Ç—Ç–∏ —Ç–∞–Ω–¥–∞–π–±—ã–∑?",
        "search_flights": "–ê–≤–∏–∞ –±–∏–ª–µ—Ç –∏–∑–¥”©”©",
        "change_language": "–¢–∏–ª–¥–∏ –∞–ª–º–∞—à—Ç—ã—Ä—É—É",
        "ask_origin": "‚úàÔ∏è –£—á—É–ø —á—ã–≥—É—É—á—É —à–∞–∞—Ä–¥—ã–Ω –∞—Ç—ã–Ω –∂–µ IATA –∫–æ–¥—É–Ω –∂–∞–∑—ã“£—ã–∑ (–º–∏—Å–∞–ª—ã, –ë–∏—à–∫–µ–∫ –∂–µ FRU).",
        "ask_destination": "üìç –≠–º–∏ –±–∞—Ä–∞ —Ç—É—Ä–≥–∞–Ω —à–∞–∞—Ä–¥—ã–Ω –∞—Ç—ã–Ω –∂–µ IATA –∫–æ–¥—É–Ω –∫–∏—Ä–≥–∏–∑–∏“£–∏–∑ (–º–∏—Å–∞–ª—ã, –î—É–±–∞–π –∂–µ DXB).",
        "ask_date": "üìÖ –£—á—É—É –∫“Ø–Ω“Ø–Ω YYYY-MM-DD —Ñ–æ—Ä–º–∞—Ç—ã–Ω–¥–∞ –∂–∞–∑—ã“£—ã–∑ –∂–µ —Ç”©–º”©–Ω–∫“Ø –±–∞—Å–∫—ã—á –∞—Ä–∫—ã–ª—É—É –∂–∞–∫—ã–Ω–∫—ã —Ä–µ–π—Å—Ç–µ—Ä–¥–∏ –∫”©—Ä“Ø“£“Ø–∑.",
        "invalid_date": "–î–∞—Ç–∞ —Ç—É—É—Ä–∞ —ç–º–µ—Å. YYYY-MM-DD —Ñ–æ—Ä–º–∞—Ç—ã–Ω–¥–∞ –∂–∞–∑—ã“£—ã–∑.",
        "invalid_city": "–®–∞–∞—Ä —Ç–∞–±—ã–ª–≥–∞–Ω –∂–æ–∫. –ê—Ç—ã–Ω –∂–µ IATA –∫–æ–¥—É–Ω –∂–∞–∑—ã“£—ã–∑.",
        "searching": "üîé –†–µ–π—Å—Ç–µ—Ä –∏–∑–¥”©”©–¥”©...",
        "error_fetch": "–†–µ–π—Å—Ç–µ—Ä –±–æ—é–Ω—á–∞ –º–∞–∞–ª—ã–º–∞—Ç –∞–ª—É—É –º“Ø–º–∫“Ø–Ω —ç–º–µ—Å. –ö–∏–π–∏–Ω –∫–∞–π—Ä–∞ –∞—Ä–∞–∫–µ—Ç –∫—ã–ª—ã“£—ã–∑.",
        "no_flights": "–ñ–∞–∫—ã–Ω–∫—ã —Ä–µ–π—Å—Ç–µ—Ä —Ç–∞–±—ã–ª–≥–∞–Ω –∂–æ–∫.",
        "results_header": "–¢–∞–±—ã–ª–≥–∞–Ω –≤–∞—Ä–∏–∞–Ω—Ç—Ç–∞—Ä:",
        "new_search": "–ñ–∞“£—ã –∏–∑–¥”©”© “Ø—á“Ø–Ω —É—á—É–ø —á—ã–≥—É—É—á—É —à–∞–∞—Ä–¥—ã–Ω –∫–æ–¥—É–Ω –∫–∞–π—Ä–∞ –∂–∞–∑—ã“£—ã–∑ –∂–µ —Ç–∏–ª–¥–∏ –∞–ª–º–∞—à—Ç—ã—Ä—É—É “Ø—á“Ø–Ω /start –∫–æ–ª–¥–æ–Ω—É“£—É–∑.",
        "missing_data": "–ò–∑–¥”©”© –º–∞–∞–ª—ã–º–∞—Ç—ã —ç—Å–∫–∏—Ä–¥–∏. /start –∂”©–Ω”©—Ç“Ø–ø –∫–∞–π—Ä–∞ –±–∞—à—Ç–∞“£—ã–∑.",
        "nearest_button": "–ñ–∞–∫—ã–Ω–∫—ã —Ä–µ–π—Å—Ç–µ—Ä",
        "departure": "–£—á—É—É",
        "arrival": "–ö–æ–Ω—É",
        "airline": "–ê–≤–∏–∞–∫–∞–º–ø–∞–Ω–∏—è",
        "flight_number": "–†–µ–π—Å",
        "price": "–ë–∞–∞—Å—ã",
        "aircraft": "–£—á–∞–∫",
    },
    "en": {
        "choose_language": "Please choose your language:",
        "choose_action": "What would you like to do?",
        "search_flights": "Search flights",
        "change_language": "Change language",
        "ask_origin": "‚úàÔ∏è Enter the departure city's name or IATA code (e.g. London or LON).",
        "ask_destination": "üìç Now provide the destination city's name or IATA code (e.g. Dubai or DXB).",
        "ask_date": "üìÖ Type the departure date in YYYY-MM-DD format or use the button below to see the nearest flights.",
        "invalid_date": "The date format is invalid. Use YYYY-MM-DD.",
        "invalid_city": "Could not recognise the city. Please enter the name or the IATA code.",
        "searching": "üîé Looking for available flights...",
        "error_fetch": "Could not retrieve flight data. Please try again later.",
        "no_flights": "No nearby flights were found.",
        "results_header": "Here are the available options:",
        "new_search": "Enter a new departure city to search again or use /start to change the language.",
        "missing_data": "Search data is outdated. Send /start to begin again.",
        "nearest_button": "Show nearest flights",
        "departure": "Departure",
        "arrival": "Arrival",
        "airline": "Airline",
        "flight_number": "Flight",
        "price": "Price",
        "aircraft": "Aircraft",
    },
}

class FlightSearch(StatesGroup):
    waiting_for_action = State()
    waiting_for_origin = State()
    waiting_for_destination = State()
    waiting_for_date = State()


def get_message(language: str, key: str) -> str:
    language_data = MESSAGES.get(language, MESSAGES["en"])
    if key in language_data:
        return language_data[key]
    return MESSAGES["en"].get(key, "")


def build_language_keyboard() -> InlineKeyboardMarkup:
    buttons: List[List[InlineKeyboardButton]] = []
    row: List[InlineKeyboardButton] = []
    for idx, (code, label) in enumerate(LANGUAGE_OPTIONS, start=1):
        row.append(InlineKeyboardButton(text=label, callback_data=f"lang:{code}"))
        if idx % 2 == 0:
            buttons.append(row)
            row = []
    if row:
        buttons.append(row)
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def build_nearest_keyboard(language: str) -> InlineKeyboardMarkup:
    button = InlineKeyboardButton(
        text=get_message(language, "nearest_button"),
        callback_data=SHOW_NEAREST_CALLBACK,
    )
    return InlineKeyboardMarkup(inline_keyboard=[[button]])


def build_main_menu(language: str) -> InlineKeyboardMarkup:
    buttons = [
        [InlineKeyboardButton(text=get_message(language, "search_flights"), callback_data=ACTION_SEARCH)],
        [InlineKeyboardButton(text=get_message(language, "change_language"), callback_data=ACTION_CHANGE_LANGUAGE)],
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_locale(language: str) -> str:
    return LANGUAGE_TO_LOCALE.get(language, "en")


LANGUAGE_TO_CURRENCY: Dict[str, str] = {
    "ru": "RUB",
    "uz": "UZS",
    "tg": "TJS",
    "kk": "KZT",
    "ky": "KGS",
    "en": "USD",
}


def get_currency(language: str) -> str:
    return LANGUAGE_TO_CURRENCY.get(language, "USD")


def init_db() -> None:
    with sqlite3.connect(DATABASE_PATH) as conn:
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS user_settings (
                user_id INTEGER PRIMARY KEY,
                language TEXT NOT NULL
            )
            """
        )
        conn.commit()


async def set_user_language(user_id: int, language: str) -> None:
    loop = asyncio.get_running_loop()

    def _set() -> None:
        with sqlite3.connect(DATABASE_PATH) as conn:
            conn.execute(
                "INSERT INTO user_settings(user_id, language) VALUES(?, ?) "
                "ON CONFLICT(user_id) DO UPDATE SET language=excluded.language",
                (user_id, language),
            )
            conn.commit()

    await loop.run_in_executor(None, _set)


async def get_user_language(user_id: int) -> Optional[str]:
    loop = asyncio.get_running_loop()

    def _get() -> Optional[str]:
        with sqlite3.connect(DATABASE_PATH) as conn:
            cursor = conn.execute(
                "SELECT language FROM user_settings WHERE user_id = ?", (user_id,)
            )
            row = cursor.fetchone()
            return row[0] if row else None

    return await loop.run_in_executor(None, _get)


async def ensure_language(state: FSMContext, user_id: int) -> str:
    data = await state.get_data()
    language = data.get("language")
    if isinstance(language, str) and language in MESSAGES:
        return language
    saved = await get_user_language(user_id)
    if isinstance(saved, str) and saved in MESSAGES:
        await state.update_data(language=saved)
        return saved
    return "en"


async def fetch_iata_code(query: str, language: str) -> Optional[str]:
    params = {
        "term": query,
        "locale": get_locale(language),
    }
    url = f"{AUTOCOMPLETE_URL}?{parse.urlencode(params)}"
    req = request.Request(url, headers={"User-Agent": "atlas-travel-bot/1.0"})

    loop = asyncio.get_running_loop()

    def _do_request() -> Optional[str]:
        try:
            with request.urlopen(req, timeout=10) as response:
                payload = response.read().decode("utf-8")
        except error.URLError as exc:  # pragma: no cover - network errors are handled gracefully
            logging.error("Failed to fetch location suggestions: %s", exc)
            return None

        try:
            data = json.loads(payload)
        except json.JSONDecodeError as exc:
            logging.error("Failed to decode location suggestions: %s", exc)
            return None

        if isinstance(data, list):
            for item in data:
                if not isinstance(item, dict):
                    continue
                code = item.get("code")
                place_type = item.get("type")
                if isinstance(code, str):
                    normalized = code.strip().upper()
                    if len(normalized) == 3 and normalized.isalpha() and place_type in {"city", "airport"}:
                        return normalized
                city_code = item.get("city_code")
                if isinstance(city_code, str):
                    normalized_city = city_code.strip().upper()
                    if len(normalized_city) == 3 and normalized_city.isalpha():
                        return normalized_city
        return None

    return await loop.run_in_executor(None, _do_request)


async def resolve_location(value: str, language: str) -> Optional[str]:
    query = value.strip()
    if not query:
        return None
    candidate = query.upper()
    if len(candidate) == 3 and candidate.isalpha():
        return candidate
    return await fetch_iata_code(query, language)


async def load_airlines() -> Dict[str, Dict[str, Any]]:
    global _AIRLINES_CACHE
    if _AIRLINES_CACHE is not None:
        return _AIRLINES_CACHE

    async with _AIRLINES_LOCK:
        if _AIRLINES_CACHE is not None:
            return _AIRLINES_CACHE

        loop = asyncio.get_running_loop()

        def _do_request() -> Dict[str, Dict[str, Any]]:
            try:
                req = request.Request(
                    AIRLINES_URL,
                    headers={"User-Agent": "atlas-travel-bot/1.0"},
                )
                with request.urlopen(req, timeout=15) as response:
                    payload = response.read().decode("utf-8")
            except error.URLError as exc:  # pragma: no cover - best effort lookup
                logging.error("Failed to fetch airlines directory: %s", exc)
                return {}

            try:
                data = json.loads(payload)
            except json.JSONDecodeError as exc:
                logging.error("Failed to parse airlines directory: %s", exc)
                return {}

            airlines: Dict[str, Dict[str, Any]] = {}
            if isinstance(data, list):
                for entry in data:
                    if not isinstance(entry, dict):
                        continue
                    code_value = entry.get("iata") or entry.get("code")
                    if not isinstance(code_value, str):
                        continue
                    code = code_value.strip().upper()
                    if len(code) != 2 or not code.isalpha():
                        continue
                    translations = entry.get("name_translations")
                    airlines[code] = {
                        "name": entry.get("name"),
                        "name_translations": translations if isinstance(translations, dict) else {},
                    }
            return airlines

        _AIRLINES_CACHE = await loop.run_in_executor(None, _do_request)
        return _AIRLINES_CACHE


def choose_airline_name(language: str, airline_info: Optional[Dict[str, Any]], code: str) -> str:
    if not airline_info:
        return code

    preference = AIRLINE_LANGUAGE_PREFERENCES.get(language, ("en", "ru"))
    translations = airline_info.get("name_translations")
    if isinstance(translations, dict):
        for locale in preference:
            translated = translations.get(locale)
            if isinstance(translated, str) and translated.strip():
                return translated.strip()

    name = airline_info.get("name")
    if isinstance(name, str) and name.strip():
        return name.strip()

    return code


async def enrich_airline_names(language: str, flights: List[Dict[str, Any]]) -> None:
    directory = await load_airlines()
    for flight in flights:
        code = flight.get("airline")
        if not isinstance(code, str):
            continue
        airline_code = code.strip().upper()
        if not airline_code:
            continue
        airline_info = directory.get(airline_code)
        flight["airline_name"] = choose_airline_name(language, airline_info, airline_code)


async def perform_search(
    chat_id: int,
    language: str,
    origin: Optional[str],
    destination: Optional[str],
    departure_date: Optional[datetime],
    state: FSMContext,
) -> None:
    if not origin or not destination:
        await bot.send_message(chat_id, get_message(language, "missing_data"))
        await state.update_data(origin=None, destination=None)
        await state.set_state(FlightSearch.waiting_for_origin)
        await bot.send_message(chat_id, get_message(language, "ask_origin"))
        return

    await bot.send_message(chat_id, get_message(language, "searching"))
    flights = await fetch_flights(origin, destination, departure_date, language)
    if flights is None:
        await bot.send_message(chat_id, get_message(language, "error_fetch"))
    elif not flights:
        await bot.send_message(chat_id, get_message(language, "no_flights"))
    else:
        await enrich_airline_names(language, flights)
        flights.sort(key=lambda item: str(item.get("departure_at", "")))
        for chunk in format_flights(language, flights):
            await bot.send_message(chat_id, chunk)

    await state.update_data(origin=None, destination=None)
    await state.set_state(FlightSearch.waiting_for_origin)
    await bot.send_message(chat_id, get_message(language, "ask_origin"))


async def fetch_flights(
    origin: str,
    destination: str,
    departure_date: Optional[datetime],
    language: str,
) -> Optional[List[Dict[str, Any]]]:
    currency = get_currency(language)
    params = {
        "origin": origin.upper(),
        "destination": destination.upper(),
        "limit": MAX_RESULTS,
        "one_way": "true",
        "token": API_TOKEN,
        "currency": currency,
        "sorting": "price",
        "unique": "false",
        "trip_class": 0,
        "page": 1,
        "locale": get_locale(language),
    }
    if departure_date:
        params["departure_at"] = departure_date.strftime("%Y-%m-%d")

    query = parse.urlencode(params)
    req = request.Request(
        f"{API_URL}?{query}",
        headers={"User-Agent": "atlas-travel-bot/1.0"},
    )

    loop = asyncio.get_running_loop()

    def _do_request() -> Optional[List[Dict[str, Any]]]:
        try:
            with request.urlopen(req, timeout=15) as response:
                payload = response.read().decode("utf-8")
        except error.URLError as exc:  # pragma: no cover - network errors are handled gracefully
            logging.error("Failed to fetch flights: %s", exc)
            return None
        try:
            body = json.loads(payload)
        except json.JSONDecodeError as exc:
            logging.error("Failed to decode response: %s", exc)
            return None
        data = body.get("data")
        if isinstance(data, list):
            return data
        return None

    return await loop.run_in_executor(None, _do_request)


def format_datetime(value: str) -> str:
    try:
        dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
    except ValueError:
        return value
    tz_suffix = ""
    if dt.tzinfo is not None:
        offset = dt.tzinfo.utcoffset(dt)
        if offset is not None:
            total_minutes = int(offset.total_seconds() // 60)
            hours, minutes = divmod(abs(total_minutes), 60)
            sign = "+" if total_minutes >= 0 else "-"
            tz_suffix = f" (UTC{sign}{hours:02d}:{minutes:02d})"
    return dt.strftime("%Y-%m-%d %H:%M") + tz_suffix


def format_flights(language: str, flights: List[Dict[str, Any]]) -> List[str]:
    header = get_message(language, "results_header")
    tail = get_message(language, "new_search")
    segments: List[str] = []
    current = header
    labels = {
        "departure": get_message(language, "departure"),
        "arrival": get_message(language, "arrival"),
        "airline": get_message(language, "airline"),
        "flight_number": get_message(language, "flight_number"),
        "price": get_message(language, "price"),
        "aircraft": get_message(language, "aircraft"),
    }
    for flight in flights:
        departure = format_datetime(str(flight.get("departure_at", "-")))
        arrival = format_datetime(str(flight.get("return_at", "-"))) if flight.get("return_at") else None
        airline = flight.get("airline_name") or flight.get("airline") or "-"
        flight_number = flight.get("flight_number") or flight.get("number") or "-"
        price = flight.get("price")
        currency = flight.get("currency", "USD")
        price_value = f"{price} {currency}" if price is not None else "-"
        aircraft = flight.get("aircraft") or flight.get("aircraft_code") or "-"

        flight_lines = [f"‚Ä¢ {labels['departure']}: {departure}"]
        if arrival:
            flight_lines.append(f"  {labels['arrival']}: {arrival}")
        flight_lines.append(f"  {labels['airline']}: {airline}")
        flight_lines.append(f"  {labels['flight_number']}: {flight_number}")
        flight_lines.append(f"  {labels['price']}: {price_value}")
        flight_lines.append(f"  {labels['aircraft']}: {aircraft}")

        block = "\n".join(flight_lines)
        addition = ("\n\n" if current else "") + block
        if len(current) + len(addition) > TELEGRAM_MESSAGE_LIMIT:
            if current:
                segments.append(current)
            current = block
        else:
            current += addition

    if tail:
        addition = ("\n\n" if current else "") + tail
        if len(current) + len(addition) <= TELEGRAM_MESSAGE_LIMIT:
            current += addition
        else:
            if current:
                segments.append(current)
            current = tail

    if current:
        segments.append(current)

    return segments


bot = Bot(
    token=TELEGRAM_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML),
)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

init_db()


@dp.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext) -> None:
    await state.clear()
    keyboard = build_language_keyboard()
    await message.answer(f"üëã\n{LANGUAGE_PROMPT}", reply_markup=keyboard)


@dp.callback_query(F.data.startswith("lang:"))
async def language_chosen(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    language_code = callback.data.split(":", maxsplit=1)[1]
    if language_code not in MESSAGES:
        language_code = "en"
    await set_user_language(callback.from_user.id, language_code)
    await state.update_data(language=language_code, origin=None, destination=None)
    await state.set_state(FlightSearch.waiting_for_action)
    await callback.message.answer(
        get_message(language_code, "choose_action"),
        reply_markup=build_main_menu(language_code),
    )


@dp.callback_query(F.data == ACTION_SEARCH)
async def handle_search_action(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    language = await ensure_language(state, callback.from_user.id)
    try:
        await callback.message.edit_reply_markup(reply_markup=None)
    except Exception:
        pass
    await state.set_state(FlightSearch.waiting_for_origin)
    await callback.message.answer(get_message(language, "ask_origin"))


@dp.callback_query(F.data == ACTION_CHANGE_LANGUAGE)
async def handle_change_language(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    await state.clear()
    keyboard = build_language_keyboard()
    await callback.message.answer(f"üëã\n{LANGUAGE_PROMPT}", reply_markup=keyboard)


@dp.message(FlightSearch.waiting_for_origin)
async def process_origin(message: Message, state: FSMContext) -> None:
    language = await ensure_language(state, message.from_user.id)
    user_data = await state.get_data()
    raw_origin = message.text or ""
    origin = await resolve_location(raw_origin, language)
    if not origin:
        if raw_origin.strip():
            await message.answer(get_message(language, "invalid_city"))
        await message.answer(get_message(language, "ask_origin"))
        return
    await state.update_data(origin=origin)
    await message.answer(get_message(language, "ask_destination"))
    await state.set_state(FlightSearch.waiting_for_destination)


@dp.message(FlightSearch.waiting_for_destination)
async def process_destination(message: Message, state: FSMContext) -> None:
    language = await ensure_language(state, message.from_user.id)
    user_data = await state.get_data()
    raw_destination = message.text or ""
    destination = await resolve_location(raw_destination, language)
    if not destination:
        if raw_destination.strip():
            await message.answer(get_message(language, "invalid_city"))
        await message.answer(get_message(language, "ask_destination"))
        return
    await state.update_data(destination=destination)
    await message.answer(
        get_message(language, "ask_date"),
        reply_markup=build_nearest_keyboard(language),
    )
    await state.set_state(FlightSearch.waiting_for_date)


@dp.message(FlightSearch.waiting_for_date)
async def process_date(message: Message, state: FSMContext) -> None:
    language = await ensure_language(state, message.from_user.id)
    user_data = await state.get_data()
    raw_date = message.text.strip()

    departure_date: Optional[datetime] = None
    if raw_date:
        try:
            departure_date = datetime.strptime(raw_date, "%Y-%m-%d")
        except ValueError:
            await message.answer(
                get_message(language, "invalid_date"),
                reply_markup=build_nearest_keyboard(language),
            )
            return

    origin = user_data.get("origin", "")
    destination = user_data.get("destination", "")
    await perform_search(message.chat.id, language, origin, destination, departure_date, state)


@dp.callback_query(F.data == SHOW_NEAREST_CALLBACK)
async def show_nearest(callback: CallbackQuery, state: FSMContext) -> None:
    await callback.answer()
    language = await ensure_language(state, callback.from_user.id)
    user_data = await state.get_data()
    origin = user_data.get("origin")
    destination = user_data.get("destination")

    try:
        await callback.message.edit_reply_markup(reply_markup=None)
    except Exception:  # pragma: no cover - message may be missing or already updated
        pass

    await perform_search(callback.message.chat.id, language, origin, destination, None, state)


async def main() -> None:
    logging.basicConfig(level=logging.INFO)
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
